{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"index","text":""},{"location":"#optimal-trade-execution-with-reinforcement-learning","title":"Optimal trade execution with reinforcement learning","text":"<p>this project is used to simulate the objective problem given in the block house repository for ml researcher task </p> <p>This project simulates the optimal trade execution strategy using the reinforcement learning and the traditional TWAP and vwap methods </p>"},{"location":"#directory-structure","title":"Directory structure","text":"<pre><code>\u2502   .gitignore\n\u2502   LICENSE\n\u2502   mkdocs.yml\n\u2502   README.md\n\u2502\n\u251c\u2500\u2500\u2500.github\n\u2502       ci.yml\n\u2502\n\u251c\u2500\u2500\u2500Blockhouse-Work-Trial\n\u2502   \u2502   agent_trades.json\n\u2502   \u2502   bid_ask.csv\n\u2502   \u2502   main.py\n\u2502   \u2502   merged_file.csv\n\u2502   \u2502   mkdocs.yml\n\u2502   \u2502   README.md\n\u2502   \u2502   twap_trades.json\n\u2502   \u2502   vwap_trades.json\n\u2502   \u251c\u2500\u2500\u2500code\n\u2502   \u2502   \u2502   benchmark_costs_script.py\n\u2502   \u2502   \u2502   Readme.md\n\u2502   \u2502   \u2502   __init__.py\n\u2502   \u251c\u2500\u2500\u2500docs\n\u2502   \u2502       index.md\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500\u2500repo\n\u2502   \u2502   \u2502   0.2.1\n\u2502   \u2502   \u2502   0.2.1'\n\u2502   \u2502   \u2502   a2c_model.zip\n\u2502   \u2502   \u2502   README.md\n\u2502   \u2502   \u2502   trade_schedule.json\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u251c\u2500\u2500\u2500datarepo\n\u2502   \u2502   \u2502   \u2502   timeframe_1.csv\n\u2502   \u2502   \u2502   \u2502   timeframe_10.csv\n\u2502   \u2502   \u2502   \u2502   ......   more files \n\u2502   \u2502   \u2514\u2500\u2500\u2500utils\n\u2502   \u2502       \u2502   agent.py\n\u2502   \u2502       \u2502   data_preprocessing.py\n\u2502   \u2502       \u2502   get_twap_trades.py\n\u2502   \u2502       \u2502   get_vwap_trades.py\n\u2502   \u2502       \u2502   log.py\n\u2502   \u2502       \u2502   __init__.py\n\u2502   \u2502       \u2502\n\u2502   \u2514\u2500\u2500\u2500research\n\u2502           agent_trades.json\n\u2502           copy.ipynb\n\u2502           merged_file.csv\n\u2502           test.ipynb\n\u2502\n\u2514\u2500\u2500\u2500docs\n        index.md\n        repo_description.md\n</code></pre>"},{"location":"getting_started/","title":"Getting started","text":"<p>Nullval a state of the art package for treatment of null values and outliers. Below is the installation and the usage guide for the package.</p> <p>Details about the package. <sup>1</sup>  Python, you can install nullval with <code>pip</code> package manager</p>"},{"location":"getting_started/#creating-a-python-virtual-environment","title":"Creating a python virtual environment","text":"<p>Before the installation of the package create a virtual environment with the supported python version </p> <p>we recommend using python version == 3.12.0</p> <p>=== \"command\"     <pre><code>conda create --name myenv python=3.12.0\n</code></pre></p> <p>replace myenv with the desired name of your virtual environment</p> <p>after te virtual environment is created activate the virtual environment using the command</p> <p>=== \"command\"     <pre><code>conda activate myenv\n</code></pre></p> <p>if you are using colab or other online based jupter notebooks run the following command below</p> <p>=== \"command\"     <pre><code>!wget https://repo.anaconda.com/miniconda/Miniconda3-py39_4.11.0-Linux-x86_64.sh\n!chmod +x Miniconda3-py39_4.11.0-Linux-x86_64.sh\n!bash ./Miniconda3-py39_4.11.0-Linux-x86_64.sh -b -f -p /usr/local\n!rm Miniconda3-py39_4.11.0-Linux-x86_64.sh\n!conda update conda\n!conda create -n myenv python==3.9.19\n%%shell\neval \"$(conda shell.bash hook)\"\nconda activate myenv\n</code></pre></p>"},{"location":"getting_started/#installation-guide","title":"Installation Guide","text":""},{"location":"getting_started/#","title":"with pip recommended","text":"<p>requirements can be downloaded using installed using  Python package and can be installed with <code>pip</code>, ideally by using a virtual environment. </p> <p>=== \"Command\"</p> <pre><code>``` \npip install -r requirements.txt\n```\n</code></pre> <p>for more information please connect with me on linkedin in github </p>"},{"location":"getting_started/#connect-with-me","title":"Connect with me","text":"<p> --&gt; linkedin</p> <p>Tip</p> <p>If you don't have prior experience with Python, we recommend reading Using Python's pip to Manage Your Projects' Dependencies, which is a really good introduction on the mechanics of Python package management and helps you troubleshoot if you run into errors.</p>"},{"location":"getting_started/#with-git","title":"with git","text":"<p>the project results can be 5replicated from the repo GitHub by cloning the</p> <pre><code>git clone https://github.com/Mukullight/blockhouse\n</code></pre>"},{"location":"getting_started/#execution","title":"Execution","text":"<pre><code>python main.py\n</code></pre>"},{"location":"getting_started/#data-pre-processing","title":"Data pre processing","text":"<p>data pre processing is a import part of data analysis </p> <p>The below functions implement the data preprocessing required for the task </p> <p>Different attributes of the data frame such as ask price, ask size, bid price and bid size along with the different prices associated with the executed trade such as opening, closing, high, low and the volume of the presented data is studied </p> <p>logger setup for easier debugging </p> <pre><code>import logging\nfrom pydantic import BaseModel, Field, validator\nfrom typing import Optional\nfrom typing import Dict, List, Any\nimport json\nimport yaml\n\n# Define a Pydantic model for logging configuration\nclass LoggingConfig(BaseModel):\n    level: str = Field(\"INFO\", description=\"Logging level (e.g., DEBUG, INFO, WARNING, ERROR, CRITICAL)\")\n    format: str = Field(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\", description=\"Log message format\")\n    datefmt: Optional[str] = Field(None, description=\"Date format for log messages\")\n\n    class Config:\n        # Ensure that Pydantic will read values from environment variables or other sources\n        env_file = \".env\"\n        env_file_encoding = 'utf-8'\n\ndef setup_logger(config: LoggingConfig) -&gt; logging.Logger:\n    \"\"\"\n    Set up the logger based on the given configuration.\n\n    Args:\n        config (LoggingConfig): The logging configuration.\n\n    Returns:\n        logging.Logger: Configured logger instance.\n    \"\"\"\n    # Create a logger instance\n    logger = logging.getLogger()\n\n    # Set the logging level\n    logger.setLevel(config.level.upper())\n\n    # Create a handler for logging to stdout\n    handler = logging.StreamHandler()\n\n    # Create and set a formatter\n    formatter = logging.Formatter(fmt=config.format, datefmt=config.datefmt)\n    handler.setFormatter(formatter)\n\n    # Add handler to the logger\n    logger.addHandler(handler)\n\n    return logger\n\n\nconfig = LoggingConfig()\nlogger = setup_logger(config)\n</code></pre>"},{"location":"getting_started/#python-code-for-the-processing-the-given-data","title":"Python code for the processing the given data","text":"<pre><code>def preprocess_data(file_path):\n    \"\"\"Load and preprocess bid-ask data.\"\"\"\n    try:\n        data = pd.read_csv(file_path)\n        data = data.dropna()\n\n        # Step 1: Find the maximum bid price and its corresponding column\n        data['max_bid_price'] = data[['bid_price_1', 'bid_price_2', 'bid_price_3', 'bid_price_4', 'bid_price_5']].max(axis=1)\n        logger.info('The maximum bid price is calculated.')\n\n        # Calculate slippage\n        data[\"slippage\"] = (data[\"close\"] - data[\"max_bid_price\"]) * data[\"volume\"]\n        logger.info('Slippage is appended to the DataFrame.')\n\n        return data\n    except FileNotFoundError:\n        logger.error(f\"File not found: {file_path}\")\n        return None\n</code></pre> <p>Purpose: Load and preprocess bid-ask data from a CSV file. Key Operations: Reads a CSV file into a DataFrame and drops rows with missing values. Calculates the maximum bid price from five specified bid price columns. Computes slippage as the product of the difference between the closing price and the maximum bid price, multiplied by the volume. Returns: The preprocessed DataFrame with new columns for maximum bid price and slippage. Error Handling: Logs an error message if the file is not found.</p>"},{"location":"getting_started/#python-code-for-the-dividing-the-data-frame-into-chucks-for-each-trading-day","title":"Python code for the dividing the data frame into chucks for each trading day","text":"<pre><code>def save_chunks(df, output_dir, timeframe=390):\n    \"\"\"Save the DataFrame in chunks of specified timeframe.\"\"\"\n    os.makedirs(output_dir, exist_ok=True)\n\n    for i in range(0, len(df), timeframe):\n        chunk = df.iloc[i:i + timeframe]\n        # Save each chunk to a CSV file\n        chunk.to_csv(os.path.join(output_dir, f'timeframe_{i // timeframe + 1}.csv'), index=False)\n        logger.info(f'Saved chunk {i // timeframe + 1} to CSV.')\n</code></pre> <p>Purpose: Save the DataFrame in chunks based on a specified timeframe. Key Operations: Creates the output directory if it does not exist. Iterates through the DataFrame in increments of the specified timeframe (default 390). Saves each chunk as a separate CSV file with a sequential filename (e.g., timeframe_1.csv). Logging: Confirms each chunk saved successfully.</p>"},{"location":"getting_started/#preprocessing-and-getting-the-final-files","title":"Preprocessing and getting the final files","text":"<pre><code>def process_input_files(input_dir):\n    \"\"\"Process CSV files in the input directory.\"\"\"\n    for filename in os.listdir(input_dir):\n        file_path = os.path.join(input_dir, filename)\n\n        # Only process CSV files\n        if filename.endswith('.csv'):\n            df = pd.read_csv(file_path)\n\n            # Check the number of rows\n            if len(df) == 390:\n                # Add a 'step' column from 1 to 390\n                df['step'] = range(1, 391)\n                df.to_csv(file_path, index=False)\n                logger.info(f'Added step column to {filename}.')\n            else:\n                # Delete the file if it doesn't have 390 rows\n                os.remove(file_path)\n                logger.info(f'Deleted {filename} due to insufficient rows.')\n\n\n\ndef merge_csv_files(input_dir):\n    output_file = 'merged_file.csv'\n    \"\"\"Merge all CSV files in the specified directory into a single CSV file.\"\"\"\n    all_data = []\n\n    for filename in os.listdir(input_dir):\n        if filename.endswith('.csv'):\n            file_path = os.path.join(input_dir, filename)\n            df = pd.read_csv(file_path)\n            all_data.append(df)\n            logger.info(f'Loaded {filename} for merging.')\n\n    merged_df = pd.concat(all_data, ignore_index=True)\n    merged_df.to_csv(output_file, index=False)\n    logger.info(f'Merged data saved to {output_file}.')\n    return merged_df\n</code></pre> <p>After the rest of the methods are carried out the json files are saved as </p> <ul> <li>agent_trades.json for reinforcement learning </li> <li>twap_trades.json for twap</li> <li>vwap_trades.json for vwap</li> </ul> <ol> <li> <p>This package is optimal trade order execution\u00a0\u21a9</p> </li> </ol>"},{"location":"twap/","title":"Twap","text":""},{"location":"twap/#time-weighted-average-price-twap","title":"Time-Weighted Average Price (TWAP)","text":"<p>Time-Weighted Average Price (TWAP) is a trading algorithm primarily used to minimize the impact of large trades on the market. TWAP aims to execute an order by evenly distributing trades across a predetermined time period, achieving an average price close to the time-weighted market price. This strategy is commonly used when liquidity is a concern, or when traders want to reduce the visibility of large orders to avoid driving prices up or down.</p>"},{"location":"twap/#key-points","title":"Key Points","text":"<ul> <li>Objective: TWAP divides an order into smaller, evenly spaced trades across the desired timeframe, reducing market impact and avoiding price spikes.</li> <li>Calculation: The TWAP price is calculated by taking the average of prices over a set interval. For example:</li> </ul> <p>[   \\text{TWAP} = \\frac{\\sum_{t=1}^{T} P_t}{T}   ]</p> <p>where \\(P_t\\) is the price at each time interval \\(t\\), and \\(T\\) is the total number of intervals.</p> <ul> <li>Use Cases: </li> <li>For illiquid stocks or large block orders that could distort the market price.</li> <li>Ideal when the market is relatively stable, as it doesn\u2019t react to sudden price movements.</li> </ul>"},{"location":"twap/#references","title":"References","text":"<ol> <li>Bouchey, P., Nemtchinov, V., Paulsen, A., &amp; Stein, D. M. (2012). Volatility Harvesting: Why Does Diversifying and Rebalancing Create Portfolio Growth? The Journal of Wealth Management.</li> <li>Johnson, B., &amp; Jackson, R. (2021). Algorithmic and High-Frequency Trading. Wiley Trading Series.</li> </ol>"},{"location":"twap/#python-code-for-the-calculation","title":"Python code for the calculation","text":""},{"location":"twap/#twap","title":"TWAP","text":"<p>The following libraries are imported for the calculation </p> <pre><code>import numpy as np\nimport pandas as pd\n</code></pre> <p>python code for calculation of the TWAP</p> <pre><code>def get_twap_trades(data, initial_inventory = 1000, preferred_timeframe=390):\n    \"\"\"\n    Generates a trade schedule based on the Time-Weighted Average Price (TWAP) strategy.\n\n    Parameters:\n    data (DataFrame): The input data containing timestamps, max_bid_price, volume, closing prices, and slippage.\n    initial_inventory (int): The total number of shares to be sold over the preferred timeframe.\n    preferred_timeframe (int): The total number of time steps (default is 390, representing a full trading day).\n\n    Returns:\n    DataFrame: A DataFrame containing the TWAP trades with timestamps, effective price, shares sold, and remaining inventory.\n    \"\"\"\n    total_steps = len(data)\n    twap_shares_per_step = initial_inventory / preferred_timeframe\n    remaining_inventory = initial_inventory\n    trades = []\n\n    for step in range(min(total_steps, preferred_timeframe)):\n        if remaining_inventory &lt;= 0:\n            break  # Stop trading if no inventory left\n\n        # Calculate effective price adjusted for slippage\n        effective_price = data.iloc[step]['max_bid_price'] - data.iloc[step]['slippage']\n\n        # Calculate the size of slice to sell\n        size_of_slice = min(np.floor(twap_shares_per_step), remaining_inventory)\n        remaining_inventory -= int(size_of_slice)\n\n        trade = {\n            'timestamp': data.iloc[step]['timestamp'],\n            'step': step,\n            'effective_price': effective_price,\n            'shares': size_of_slice,\n            'inventory': remaining_inventory,\n        }\n        trades.append(trade)\n\n    return pd.DataFrame(trades)\n</code></pre>"},{"location":"vwap/","title":"Vwap","text":""},{"location":"vwap/#volume-weighted-average-price-vwap","title":"Volume-Weighted Average Price (VWAP)","text":"<p>Volume-Weighted Average Price (VWAP) is a trading benchmark that calculates the average price of a security, weighted by the trading volume, over a specified period. VWAP is commonly used in large order execution strategies to minimize market impact by aligning trades with the market\u2019s volume patterns, helping traders avoid significantly moving the price.</p>"},{"location":"vwap/#key-points","title":"Key Points","text":"<ul> <li>Objective: VWAP helps traders execute orders at a price close to the market\u2019s average trading price, adjusted for volume. This approach reduces the risk of affecting the price with large orders, making it particularly useful for institutional traders.</li> <li>Calculation: VWAP is calculated by taking the sum of the product of price and volume for each trade, divided by the total volume over the specified period. Mathematically:</li> </ul> <p>[   \\text{VWAP} = \\frac{\\sum_{t=1}^{T} (P_t \\times V_t)}{\\sum_{t=1}^{T} V_t}   ]</p> <p>where:   - \\(P_t\\) is the price at time interval \\(t\\)   - \\(V_t\\) is the volume at time interval \\(t\\)   - \\(T\\) is the total number of intervals.</p> <ul> <li>Use Cases:</li> <li>Institutional Trading: VWAP is a common benchmark in institutional trading, often considered a \u201cfair\u201d price for large block orders.</li> <li>Passive Execution: Traders who aim to minimize their market impact may use VWAP to match their trades to existing volume patterns.</li> </ul>"},{"location":"vwap/#advantages-and-limitations","title":"Advantages and Limitations","text":"<ul> <li>Advantages: </li> <li>Helps avoid significant price impact.</li> <li>Useful for achieving a price close to the market average over a period, especially in liquid markets.</li> <li>Limitations:</li> <li>Less suitable in highly volatile or low-volume markets, where large orders can still disrupt the price.</li> </ul>"},{"location":"vwap/#references","title":"References","text":"<ol> <li>Madhavan, A. (2002). VWAP Strategies in Equity Trading. Institutional Investor.</li> <li>Kissell, R., &amp; Malamut, R. (2006). Algorithmic Decision Making Framework: Trading Efficiency with Volume Weighted Average Price (VWAP).</li> </ol>"},{"location":"vwap/#python-code-for-the-calculation","title":"Python code for the calculation","text":""},{"location":"vwap/#vwap","title":"VWAP","text":"<p>The following libraries are imported for the calculation </p> <pre><code>import numpy as np\nimport pandas as pd\n</code></pre> <p>python code for calculation of the vwap</p> <pre><code>def get_vwap_trades(data, initial_inventory = 1000, preferred_timeframe=390):\n    \"\"\"\n    Generates a trade schedule based on the Volume-Weighted Average Price (VWAP) strategy.\n\n    Parameters:\n    data (DataFrame): The input data containing timestamps, max_bid_price, volume, closing prices, and slippage.\n    initial_inventory (int): The total number of shares to be sold over the preferred timeframe.\n    preferred_timeframe (int): The total number of time steps (default is 390, representing a full trading day).\n\n    Returns:\n    DataFrame: A DataFrame containing the VWAP trades with timestamps, effective price, shares sold, and remaining inventory.\n    \"\"\"\n    # Calculate the total volume over the preferred timeframe\n    total_volume = data['volume'][:preferred_timeframe].sum()\n    remaining_inventory = initial_inventory\n    trades = []\n\n    for step in range(min(len(data), preferred_timeframe)):\n        if remaining_inventory &lt;= 0:\n            break  # Stop trading if no inventory left\n\n        # Volume proportion for the current step\n        volume_proportion = data.iloc[step]['volume'] / total_volume if total_volume &gt; 0 else 0\n\n        # Calculate the size of slice to sell based on VWAP allocation\n        size_of_slice = min(np.floor(volume_proportion * initial_inventory), remaining_inventory)\n        remaining_inventory -= int(size_of_slice)\n\n        # Calculate effective price adjusted for slippage\n        effective_price = data.iloc[step]['max_bid_price'] - data.iloc[step]['slippage']\n\n        trade = {\n            'timestamp': data.iloc[step]['timestamp'],\n            'step': step,\n            'effective_price': effective_price,\n            'shares': size_of_slice,\n            'inventory': remaining_inventory,\n        }\n        trades.append(trade)\n\n    return pd.DataFrame(trades)\n</code></pre>"},{"location":"agents/agents/","title":"VWAP reinforcement learning Environment Class Explanation","text":"<p>The <code>VWAPEnvironment</code> class defines a custom OpenAI Gym environment for simulating trade execution based on the Volume Weighted Average Price (VWAP) strategy. Below is a detailed explanation of each component and method within the class.</p>"},{"location":"agents/agents/#class-definition","title":"Class Definition","text":"<pre><code>class VWAPEnvironment(gym.Env):\n    def __init__(self, data, initial_inventory, preferred_timeframe=390):\n    super(VWAPEnvironment, self).__init__()\n</code></pre> <p>Parameters:</p> <p>data: A pandas DataFrame containing market data (e.g., bid prices, volume, slippage). initial_inventory: The starting number of shares available for trading. preferred_timeframe: The time frame in minutes over which trading is simulated (default is 390). The super() call initializes the parent class gym.Env.</p>"},{"location":"agents/agents/#action-space","title":"Action space","text":"<p>+Action Space: The action space is defined as a discrete space with 4 possible actions. This could represent different quantities of shares to sell (e.g., 0, 1, 2, or 3 shares).</p> <pre><code>self.action_space = spaces.Discrete(4)  \n</code></pre>"},{"location":"agents/agents/#observation-space","title":"observation space","text":"<ul> <li>Observation Space: The observation space is defined as a dictionary containing:</li> <li>max_bid_price: The maximum bid price at the current step (float).</li> <li>volume: The trading volume at the current step (float).</li> <li>close: The closing price at the current step (float).</li> <li>slippage: The slippage at the current step (float).</li> <li>remaining_inventory: The number of shares remaining to trade (integer).</li> </ul> <pre><code>self.observation_space = spaces.Dict({\n    'max_bid_price': spaces.Box(low=0, high=np.inf, shape=(1,), dtype=np.float32),\n    'volume': spaces.Box(low=0, high=np.inf, shape=(1,), dtype=np.float32),\n    'close': spaces.Box(low=0, high=np.inf, shape=(1,), dtype=np.float32),\n    'slippage': spaces.Box(low=0, high=np.inf, shape=(1,), dtype=np.float32),\n    'remaining_inventory': spaces.Box(low=0, high=self.initial_inventory, shape=(1,), dtype=np.int32),\n})\n</code></pre>"},{"location":"agents/agents/#reset-and-observation-method","title":"Reset and observation method","text":"<p>Purpose: Resets the environment to its initial state. Attributes Reset: current_step: Resets the step counter to 0. remaining_inventory: Resets the inventory to the initial inventory. trades: Initializes an empty list to store the history of trades. Returns: Calls _get_observation() to return the initial state of the environment.</p> <pre><code>def reset(self):\n    self.current_step = 0\n    self.remaining_inventory = self.initial_inventory\n    self.trades = []  # Initialize as a list to store trade history\n    return self._get_observation()\ndef _get_observation(self):\n    return {\n        'max_bid_price': np.array([self.data.iloc[self.current_step]['max_bid_price']]),\n        'volume': np.array([self.data.iloc[self.current_step]['volume']]),\n        'close': np.array([self.data.iloc[self.current_step]['close']]),\n        'slippage': np.array([self.data.iloc[self.current_step]['slippage']]),\n        'remaining_inventory': np.array([self.remaining_inventory]),\n    }\n</code></pre>"},{"location":"agents/agents/#reward-calculation-method","title":"Reward calculation method","text":"<p><pre><code>def _calculate_reward(self, shares_to_sell, effective_price):\n    # Calculate VWAP for the current step\n    total_volume = self.data['volume'][:self.preferred_timeframe].sum()\n    ideal_vwap_allocation = (self.data.iloc[self.current_step]['volume'] / total_volume) * self.initial_inventory\n\n    # Calculate the deviation penalty\n    vwap_deviation_penalty = -abs(shares_to_sell - ideal_vwap_allocation)\n\n    # Calculate the slippage penalty\n    slippage_penalty = -(self.data.iloc[self.current_step]['slippage'] * shares_to_sell)\n\n    # Combine the components into the total reward\n    reward = vwap_deviation_penalty + slippage_penalty \n    return reward\n</code></pre> and the agent is called in the main function</p>"}]}